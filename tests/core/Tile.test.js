/**
 * Tile ÂçïÂÖÉÊµãËØï
 * ÊµãËØïÊñπÂùóÁ±ªÁöÑÊ†∏ÂøÉÂäüËÉΩ
 */

// Ê®°ÊãüTileÁ±ª
global.Tile = class Tile {
    constructor(x, y, value) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.id = `tile_${Date.now()}_${Math.random()}`;
        this.isNew = false;
        this.isMerged = false;
        this.mergedFrom = null;
        this.element = null;
        this.animationData = {};
    }
    
    canMergeWith(other) {
        if (!other) return false;
        return other.value === this.value && 
               !other.isMerged && 
               !this.isMerged;
    }
    
    getMergedValue() {
        return this.value * 2;
    }
    
    markAsNew() {
        this.isNew = true;
    }
    
    markAsMerged(tiles = []) {
        this.isMerged = true;
        this.mergedFrom = tiles;
    }
    
    resetFlags() {
        this.isNew = false;
        this.isMerged = false;
        this.mergedFrom = null;
    }
    
    updatePosition(x, y) {
        this.x = x;
        this.y = y;
    }
    
    clone() {
        const clone = new Tile(this.x, this.y, this.value);
        clone.id = this.id;
        clone.isNew = this.isNew;
        clone.isMerged = this.isMerged;
        clone.mergedFrom = this.mergedFrom;
        return clone;
    }
    
    render(ctx, canvasSize, themeConfig, gridSize) {
        // Ê®°ÊãüÊ∏≤ÊüìÈÄªËæë
        const cellSize = canvasSize / gridSize;
        const gap = cellSize * 0.1;
        const actualCellSize = cellSize - gap;
        
        const posX = this.x * cellSize + gap;
        const posY = this.y * cellSize + gap;
        
        // ÁªòÂà∂ÊñπÂùóËÉåÊôØ
        ctx.fillStyle = this.getTileColor();
        ctx.fillRect(posX, posY, actualCellSize, actualCellSize);
        
        // ÁªòÂà∂Êï∞ÂÄº
        ctx.fillStyle = this.getTextColor();
        ctx.font = this.getFontSize(actualCellSize) + 'px Arial';
        ctx.fillText(this.value.toString(), posX + actualCellSize / 2, posY + actualCellSize / 2);
    }
    
    getTileColor() {
        const colorMap = {
            2: '#EEE4DA',
            4: '#EDE0C8',
            8: '#F2B179',
            16: '#F59563',
            32: '#F67C5F',
            64: '#F65E3B',
            128: '#EDCF72',
            256: '#EDCC61',
            512: '#EDC850',
            1024: '#EDC53F',
            2048: '#EDC22E'
        };
        return colorMap[this.value] || '#3C3A32';
    }
    
    getTextColor() {
        return this.value <= 4 ? '#776E65' : '#F9F6F2';
    }
    
    getFontSize(cellSize) {
        if (this.value < 100) return Math.floor(cellSize * 0.4);
        if (this.value < 1000) return Math.floor(cellSize * 0.35);
        return Math.floor(cellSize * 0.3);
    }
    
    updateAnimation(deltaTime) {
        // Êõ¥Êñ∞Âä®ÁîªÁä∂ÊÄÅ
        if (this.animationData.type) {
            this.animationData.currentTime = (this.animationData.currentTime || 0) + deltaTime;
            
            if (this.animationData.currentTime >= this.animationData.duration) {
                this.animationData = {}; // Ê∏ÖÈô§Âä®ÁîªÊï∞ÊçÆ
            }
        }
    }
    
    startAnimation(type, duration, data = {}) {
        this.animationData = {
            type,
            duration,
            currentTime: 0,
            ...data
        };
    }
    
    isAnimating() {
        return !!this.animationData.type;
    }
    
    getDisplayValue() {
        // Ê†πÊçÆ‰∏ªÈ¢òËøîÂõûÊòæÁ§∫ÂÄºÔºàÂèØËÉΩÊòØÂõæÊ†áÊàñÊï∞Â≠óÔºâ
        const nezhaSymbols = {
            2: 'ü™∑', // Ëé≤Ëä±
            4: 'üî•', // ÁÅ´
            8: 'üåä', // Ê∑∑Â§©Áª´
            16: '‚≠ï', // ‰πæÂù§Âúà
            32: '‚ö°', // Èõ∑Áîµ
            64: 'üó°Ô∏è', // Ââë
            128: 'üõ°Ô∏è', // Áõæ
            256: 'üëë', // ÁéãÂÜ†
            512: 'üêâ', // Èæô
            1024: '‚ö°', // Á•ûÂäõ
            2048: 'üî±' // ‰∏âÂèâÊàü
        };
        
        return nezhaSymbols[this.value] || this.value.toString();
    }
    
    equals(other) {
        if (!other) return false;
        return this.x === other.x && 
               this.y === other.y && 
               this.value === other.value;
    }
    
    toString() {
        return `Tile(${this.x}, ${this.y}, ${this.value})`;
    }
};

describe('Tile', () => {
    let tile;

    beforeEach(() => {
        tile = new Tile(1, 2, 4);
    });

    describe('ÊûÑÈÄ†ÂáΩÊï∞', () => {
        test('Â∫îËØ•Ê≠£Á°ÆÂàùÂßãÂåñTileÂÆû‰æã', () => {
            expect(tile.x).toBe(1);
            expect(tile.y).toBe(2);
            expect(tile.value).toBe(4);
            expect(tile.id).toBeDefined();
            expect(tile.isNew).toBe(false);
            expect(tile.isMerged).toBe(false);
        });

        test('Â∫îËØ•ÁîüÊàêÂîØ‰∏ÄÁöÑID', () => {
            const tile1 = new Tile(0, 0, 2);
            const tile2 = new Tile(0, 0, 2);
            
            expect(tile1.id).not.toBe(tile2.id);
        });
    });

    describe('ÂêàÂπ∂Ê£ÄÊµã', () => {
        test('Â∫îËØ•ËÉΩÂ§ü‰∏éÁõ∏ÂêåÂÄºÁöÑÊñπÂùóÂêàÂπ∂', () => {
            const otherTile = new Tile(2, 2, 4);
            
            expect(tile.canMergeWith(otherTile)).toBe(true);
        });

        test('Â∫îËØ•‰∏çËÉΩ‰∏é‰∏çÂêåÂÄºÁöÑÊñπÂùóÂêàÂπ∂', () => {
            const otherTile = new Tile(2, 2, 8);
            
            expect(tile.canMergeWith(otherTile)).toBe(false);
        });

        test('Â∫îËØ•‰∏çËÉΩ‰∏éÂ∑≤ÂêàÂπ∂ÁöÑÊñπÂùóÂêàÂπ∂', () => {
            const otherTile = new Tile(2, 2, 4);
            otherTile.isMerged = true;
            
            expect(tile.canMergeWith(otherTile)).toBe(false);
        });

        test('Â∫îËØ•‰∏çËÉΩÂú®Ëá™Â∑±Â∑≤ÂêàÂπ∂Êó∂ÂêàÂπ∂', () => {
            const otherTile = new Tile(2, 2, 4);
            tile.isMerged = true;
            
            expect(tile.canMergeWith(otherTile)).toBe(false);
        });

        test('Â∫îËØ•‰∏çËÉΩ‰∏énullÂêàÂπ∂', () => {
            expect(tile.canMergeWith(null)).toBe(false);
        });
    });

    describe('ÂêàÂπ∂ÂÄºËÆ°ÁÆó', () => {
        test('Â∫îËØ•ËøîÂõûÊ≠£Á°ÆÁöÑÂêàÂπ∂ÂÄº', () => {
            expect(tile.getMergedValue()).toBe(8); // 4 * 2
        });

        test('Â∫îËØ•‰∏∫‰∏çÂêåÂÄºËøîÂõûÊ≠£Á°ÆÁöÑÂêàÂπ∂ÂÄº', () => {
            const tile2 = new Tile(0, 0, 2);
            const tile1024 = new Tile(0, 0, 1024);
            
            expect(tile2.getMergedValue()).toBe(4);
            expect(tile1024.getMergedValue()).toBe(2048);
        });
    });

    describe('Áä∂ÊÄÅÊ†áËÆ∞', () => {
        test('Â∫îËØ•ËÉΩÂ§üÊ†áËÆ∞‰∏∫Êñ∞ÊñπÂùó', () => {
            tile.markAsNew();
            expect(tile.isNew).toBe(true);
        });

        test('Â∫îËØ•ËÉΩÂ§üÊ†áËÆ∞‰∏∫Â∑≤ÂêàÂπ∂', () => {
            const sourceTiles = [new Tile(0, 0, 2), new Tile(1, 0, 2)];
            
            tile.markAsMerged(sourceTiles);
            
            expect(tile.isMerged).toBe(true);
            expect(tile.mergedFrom).toBe(sourceTiles);
        });

        test('Â∫îËØ•ËÉΩÂ§üÈáçÁΩÆÊ†áÂøó', () => {
            tile.markAsNew();
            tile.markAsMerged();
            
            tile.resetFlags();
            
            expect(tile.isNew).toBe(false);
            expect(tile.isMerged).toBe(false);
            expect(tile.mergedFrom).toBeNull();
        });
    });

    describe('‰ΩçÁΩÆÊõ¥Êñ∞', () => {
        test('Â∫îËØ•ËÉΩÂ§üÊõ¥Êñ∞‰ΩçÁΩÆ', () => {
            tile.updatePosition(3, 4);
            
            expect(tile.x).toBe(3);
            expect(tile.y).toBe(4);
        });
    });

    describe('ÂÖãÈöÜ', () => {
        test('Â∫îËØ•ÂàõÂª∫Ê≠£Á°ÆÁöÑÂÖãÈöÜ', () => {
            tile.markAsNew();
            tile.markAsMerged();
            
            const clone = tile.clone();
            
            expect(clone).not.toBe(tile);
            expect(clone.x).toBe(tile.x);
            expect(clone.y).toBe(tile.y);
            expect(clone.value).toBe(tile.value);
            expect(clone.id).toBe(tile.id);
            expect(clone.isNew).toBe(tile.isNew);
            expect(clone.isMerged).toBe(tile.isMerged);
        });
    });

    describe('Ê∏≤Êüì', () => {
        let mockCtx;
        let mockThemeConfig;

        beforeEach(() => {
            mockCtx = {
                fillStyle: '',
                font: '',
                fillRect: jest.fn(),
                fillText: jest.fn()
            };
            
            mockThemeConfig = {
                colors: {
                    background: '#8B4513',
                    primary: '#DC143C'
                }
            };
        });

        test('Â∫îËØ•ËÉΩÂ§üÊ∏≤ÊüìÊñπÂùó', () => {
            tile.render(mockCtx, 400, mockThemeConfig, 4);
            
            expect(mockCtx.fillRect).toHaveBeenCalled();
            expect(mockCtx.fillText).toHaveBeenCalledWith('4', expect.any(Number), expect.any(Number));
        });

        test('Â∫îËØ•‰∏∫‰∏çÂêåÂÄº‰ΩøÁî®‰∏çÂêåÈ¢úËâ≤', () => {
            const tile2 = new Tile(0, 0, 2);
            const tile8 = new Tile(0, 0, 8);
            
            const color2 = tile2.getTileColor();
            const color8 = tile8.getTileColor();
            
            expect(color2).not.toBe(color8);
        });

        test('Â∫îËØ•‰∏∫Â∞èÊï∞ÂÄº‰ΩøÁî®Ê∑±Ëâ≤ÊñáÂ≠ó', () => {
            const tile2 = new Tile(0, 0, 2);
            expect(tile2.getTextColor()).toBe('#776E65');
        });

        test('Â∫îËØ•‰∏∫Â§ßÊï∞ÂÄº‰ΩøÁî®ÊµÖËâ≤ÊñáÂ≠ó', () => {
            const tile8 = new Tile(0, 0, 8);
            expect(tile8.getTextColor()).toBe('#F9F6F2');
        });

        test('Â∫îËØ•Ê†πÊçÆÊï∞ÂÄºË∞ÉÊï¥Â≠ó‰ΩìÂ§ßÂ∞è', () => {
            const tile2 = new Tile(0, 0, 2);
            const tile100 = new Tile(0, 0, 100);
            const tile1000 = new Tile(0, 0, 1000);
            
            const cellSize = 100;
            const fontSize2 = tile2.getFontSize(cellSize);
            const fontSize100 = tile100.getFontSize(cellSize);
            const fontSize1000 = tile1000.getFontSize(cellSize);
            
            expect(fontSize2).toBeGreaterThan(fontSize100);
            expect(fontSize100).toBeGreaterThan(fontSize1000);
        });
    });

    describe('Âä®Áîª', () => {
        test('Â∫îËØ•ËÉΩÂ§üÂºÄÂßãÂä®Áîª', () => {
            tile.startAnimation('move', 1000, { fromX: 0, toX: 1 });
            
            expect(tile.animationData.type).toBe('move');
            expect(tile.animationData.duration).toBe(1000);
            expect(tile.animationData.currentTime).toBe(0);
            expect(tile.animationData.fromX).toBe(0);
            expect(tile.animationData.toX).toBe(1);
        });

        test('Â∫îËØ•Ê£ÄÊµãÊòØÂê¶Âú®Âä®Áîª‰∏≠', () => {
            expect(tile.isAnimating()).toBe(false);
            
            tile.startAnimation('appear', 500);
            expect(tile.isAnimating()).toBe(true);
        });

        test('Â∫îËØ•Êõ¥Êñ∞Âä®ÁîªÁä∂ÊÄÅ', () => {
            tile.startAnimation('fade', 1000);
            
            tile.updateAnimation(500);
            expect(tile.animationData.currentTime).toBe(500);
            
            tile.updateAnimation(600); // ÊÄªÂÖ±1100msÔºåË∂ÖËøáÊåÅÁª≠Êó∂Èó¥
            expect(tile.animationData.type).toBeUndefined(); // Âä®ÁîªÂ∫îËØ•ÁªìÊùü
        });
    });

    describe('ÊòæÁ§∫ÂÄº', () => {
        test('Â∫îËØ•‰∏∫Âì™Âêí‰∏ªÈ¢òËøîÂõûÁ¨¶Âè∑', () => {
            const tile2 = new Tile(0, 0, 2);
            const tile4 = new Tile(0, 0, 4);
            
            expect(tile2.getDisplayValue()).toBe('ü™∑');
            expect(tile4.getDisplayValue()).toBe('üî•');
        });

        test('Â∫îËØ•‰∏∫Êú™ÂÆö‰πâÁöÑÂÄºËøîÂõûÊï∞Â≠ó', () => {
            const tile4096 = new Tile(0, 0, 4096);
            expect(tile4096.getDisplayValue()).toBe('4096');
        });
    });

    describe('ÊØîËæÉ', () => {
        test('Â∫îËØ•Ê≠£Á°ÆÊØîËæÉÁõ∏Á≠âÁöÑÊñπÂùó', () => {
            const otherTile = new Tile(1, 2, 4);
            expect(tile.equals(otherTile)).toBe(true);
        });

        test('Â∫îËØ•Ê≠£Á°ÆÊØîËæÉ‰∏çÂêå‰ΩçÁΩÆÁöÑÊñπÂùó', () => {
            const otherTile = new Tile(2, 2, 4);
            expect(tile.equals(otherTile)).toBe(false);
        });

        test('Â∫îËØ•Ê≠£Á°ÆÊØîËæÉ‰∏çÂêåÂÄºÁöÑÊñπÂùó', () => {
            const otherTile = new Tile(1, 2, 8);
            expect(tile.equals(otherTile)).toBe(false);
        });

        test('Â∫îËØ•Â§ÑÁêÜnullÊØîËæÉ', () => {
            expect(tile.equals(null)).toBe(false);
        });
    });

    describe('Â≠óÁ¨¶‰∏≤Ë°®Á§∫', () => {
        test('Â∫îËØ•ËøîÂõûÊ≠£Á°ÆÁöÑÂ≠óÁ¨¶‰∏≤Ë°®Á§∫', () => {
            expect(tile.toString()).toBe('Tile(1, 2, 4)');
        });
    });

    describe('ËæπÁïåÊÉÖÂÜµ', () => {
        test('Â∫îËØ•Â§ÑÁêÜÈõ∂ÂÄº', () => {
            const zeroTile = new Tile(0, 0, 0);
            expect(zeroTile.value).toBe(0);
            expect(zeroTile.getMergedValue()).toBe(0);
        });

        test('Â∫îËØ•Â§ÑÁêÜË¥üÂÄº', () => {
            const negativeTile = new Tile(0, 0, -2);
            expect(negativeTile.value).toBe(-2);
            expect(negativeTile.getMergedValue()).toBe(-4);
        });

        test('Â∫îËØ•Â§ÑÁêÜÂ§ßÊï∞ÂÄº', () => {
            const largeTile = new Tile(0, 0, 65536);
            expect(largeTile.value).toBe(65536);
            expect(largeTile.getMergedValue()).toBe(131072);
        });
    });

    describe('ÂÜÖÂ≠òÁÆ°ÁêÜ', () => {
        test('Â∫îËØ•ËÉΩÂ§üÊ∏ÖÁêÜÂä®ÁîªÊï∞ÊçÆ', () => {
            tile.startAnimation('test', 100);
            tile.updateAnimation(200); // Ë∂ÖËøáÊåÅÁª≠Êó∂Èó¥
            
            expect(Object.keys(tile.animationData).length).toBe(0);
        });

        test('Â∫îËØ•ËÉΩÂ§üÈáçÁΩÆÊâÄÊúâÁä∂ÊÄÅ', () => {
            tile.markAsNew();
            tile.markAsMerged();
            tile.startAnimation('test', 1000);
            
            tile.resetFlags();
            tile.animationData = {};
            
            expect(tile.isNew).toBe(false);
            expect(tile.isMerged).toBe(false);
            expect(tile.isAnimating()).toBe(false);
        });
    });
});